import numpy as np
import pandas as pd
import fastdtw
import os
from statsmodels.tsa.stattools import coint

def data_import(path='D:/data/sp500_ibapi/summary.csv'):
    data = pd.read_csv(path)  
    train_data = data[0:506]
    test_data = data[506:data.shape[0]]
    
    columns_with_nulls = train_data.columns[train_data.isnull().any()].tolist()
    
    # Drop the identified columns from both train and test data
    train_data = train_data.drop(columns=columns_with_nulls)
    test_data = test_data.drop(columns=columns_with_nulls)
    
    drop_count = len(columns_with_nulls)
    print(f'Dropped {drop_count} columns with null values in training data.')
    
    return train_data, test_data

def scaler_fit(data):
    col_name = data.columns
    scaling = {}
    for ticket in col_name:
        scaling[ticket] = np.mean(data[ticket])
    return scaling

def scaler_transform(data, scaler, inverse=False):
    if inverse:
        for element in data.columns:
            data[element] = data[element]*scaler[element]
        return data.reset_index(drop=True)
    else:
        for element in data.columns:
            data[element] = data[element]/scaler[element]
        return data.reset_index(drop=True)

def data_preprocess(train_data, test_data):
    scaler = scaler_fit(train_data)
    norm_train_data = scaler_transform(train_data, scaler)
    norm_test_data = scaler_transform(test_data, scaler)
    return norm_train_data, norm_test_data, scaler

def combination(list):
    output = []
    for i in range(len(list)-1):
        for j in range(len(list)-i-1):
            output.append([list[i], list[i+j+1]])
    return output

def dwt_find_pair(data, criteria=50, test_mode=False, reload=False):
    column_list = data.columns.to_list()
    test_pair = combination(column_list)
    dist = []
    
    if reload:
        print("retreive last pair data")
        pair_record = pd.read_csv("D:/data/algo_package/pair/dwt.csv")
        pair_record = pair_record[pair_record['dist'] < criteria]                     
        print(f'retreived {pair_record.shape[0]} dtw pair data')      
        return pair_record.values.tolist()

    for pair in test_pair:
        stock1 = data[pair[0]].dropna()
        stock2 = data[pair[1]].dropna()
        dwt_dist = fastdtw.fastdtw(stock1, stock2)[0]
        
        if dwt_dist < criteria:
            print('Found new pair ' + str(pair) + ' with distance : ' + str(dwt_dist))
            dist.append([pair[0], pair[1], dwt_dist])
            
        if (len(dist) > 10) & test_mode:
            pair_record = pd.DataFrame(dist, columns=['pair1', 'pair2', 'dist'])
            pair_record.to_csv('D:/data/algo_package/pair/' + str(criteria) + ".csv", index=False)
            return dist
        
    pair_record = pd.DataFrame(dist, columns=['pair1', 'pair2', 'dist'])
    pair_record.to_csv('D:/data/algo_package/pair/dwt' + str(criteria) + ".csv", index=False)
    print('total pair found :'+ str(len(dist)))
    
    return dist

def coint_find_pair(data, dwt_pair, reload=False):
    
    if reload:
        print("retreive last coint pair data")
        pair_record = pd.read_csv('D:/data/algo_package/pair/coint' + ".csv")
        print(f'retreived {pair_record.shape[0]} coint pair data')
        return pair_record.values.tolist()
    
    trade_list = []
    for pair in dwt_pair:
        price_1, price_2 = data[pair[0]], data[pair[1]]
        t_stat, p_value, cri_value = coint(price_1, price_2, trend='c')
        if p_value < 0.05:
            print('Trade pair ' + pair[0] + ' & ' + pair[1] +' pass the test with t-stat :'+ str(t_stat) + ', p-value :'+ str(p_value))
            trade_list.append(pair)
    
    pair_record = pd.DataFrame(trade_list, columns=['pair1', 'pair2', 'dist'])
    pair_record.to_csv('D:/data/algo_package/pair/coint' + ".csv", index=False)
    print('total pair pass the test :'+ str(len(trade_list)))
    
    return trade_list

def pair_divergence(data, pair_list):
    pair_div = {}
    for pair in pair_list:
        stock_1, stock_2 = pair[0], pair[1]
        price_1, price_2 = data[stock_1], data[stock_2]
        diff = np.mean(abs(price_1 - price_2))
        pair_div[str(stock_1 + '&' + stock_2)] = diff
    return pair_div
    
def enter(price_a, price_b, direction, equity=10000):
    if direction:
        long_position = equity/price_b[1]
        short_position = equity/price_a[1]
        return [price_b[0], long_position, price_a[0], short_position, equity, price_b[1], price_a[1], 0]
    
    else:
        long_position = equity/price_a[1]
        short_position = equity/price_b[1]
        return [price_a[0], long_position, price_b[0], short_position, equity, price_a[1], price_b[1], 0]

def close(record, current_value):
    
    close_long_position = record[1] * current_value[1]
    close_short_position = record[3] * current_value[0]
    equity = record[4] + close_long_position - close_short_position

    return [record[2], record[3], record[0], record[1], equity, current_value[1], current_value[0], (equity/record[4])-1]
    
def trade_execute(norm_test_data, trade_pair, scaler, gap=0.1):
    
    stock1 = norm_test_data[trade_pair[0]].dropna()
    stock2 = norm_test_data[trade_pair[1]].dropna()
    test_data = scaler_transform(norm_test_data, scaler, inverse=True)
    stock1_price = test_data[trade_pair[0]]
    stock2_price = test_data[trade_pair[1]]

    trade_period = min(len(stock1), len(stock2))
    equity = 10000
    in_position = False
    trade_record = []
    
    for i in range(1, trade_period):
            
        direction_before = bool(stock1[i-1] >= stock2[i-1])
        direction = bool(stock1[i] >= stock2[i])

        #not in position, gap large
        if (abs(stock1[i] - stock2[i]) > gap*2) & (not in_position):
            in_position = True
            record = enter([trade_pair[0], stock1_price[i]], [trade_pair[1], stock2_price[i]], direction, equity)
            trade_record.append(record)

        #in position, price cross
        if in_position & (direction_before != direction):
            in_position = False
            current_value = [stock1_price[i], stock2_price[i]] if direction_before else [stock2_price[i], stock1_price[i]]
            close_record = close(record, current_value)
            equity = close_record[4]
            trade_record.append(close_record)

        #in postion, forcibly liquidate when time end
        if in_position & (i == trade_period - 1):
            current_value = [stock1_price[i], stock2_price[i]] if direction_before else [stock2_price[i], stock1_price[i]]
            close_record = close(record, current_value)
            equity = close_record[4]
            trade_record.append(close_record)
            
    #print("Trade execution for " + trade_pair[0] + ' & ' + trade_pair[1] + " completed.")

    return trade_record 

def review_by_pair(trade_record, pair):
    
    final = trade_record[-1][4]
    
    df_trade_record = pd.DataFrame(trade_record, columns=['long', 'unit_long','short', 'unit_short', 'equity', 'price_long', 'price_short', 'percent_change'])
    df_trade_record['name1'] = pair[0]
    df_trade_record['name2'] = pair[1]    
    
    if final > 10000:
        df_trade_record['profitable'] = 1
        df_trade_record.to_csv("D:/data/algo_package/good/" + pair[0] + '&' + pair[1] + "_summary.csv", index=False)
    
    if final < 10000:
        df_trade_record['profitable'] = 0
        df_trade_record.to_csv("D:/data/algo_package/bad/" + pair[0] + '&' + pair[1] + "_summary.csv", index=False)
    
    if np.isnan(final):
        print('No trade record found for '+ pair[0] + '&' + pair[1])
        return 0
    
    return final

def trade_study(trade_record, trade_pair):

    if sum(trade_record['return']) > 0:
        print(trade_pair)
        return 1 
    return 0 
############################
def main():
    ### preprocess
    train_data, test_data = data_import()
    norm_train_data, norm_test_data, scaler = data_preprocess(train_data, test_data)

    ### first find pair that are similar, then perform cointegration test
    reload_index = True
    dwt_list = dwt_find_pair(norm_train_data, criteria=14, reload=reload_index)
    trade_list = coint_find_pair(norm_train_data, dwt_list)
    #trade_list = dwt_list
    
    entering_criteria = pair_divergence(norm_train_data, trade_list)

    trade_summary = []
    finalresult = 0
    # trade_execute and review by pair
    for trade_pair in trade_list:
        
        pair_name = trade_pair[0] + '&' + trade_pair[1]
        trade_record = trade_execute(norm_test_data.copy(), trade_pair, scaler, gap=entering_criteria[pair_name])
    
        finalresult += review_by_pair(trade_record, trade_pair)
    
        if len(trade_record) > 0:
            trade_summary.extend(trade_record)
        else:
            print('No trade record found for '+ pair_name)
        
    print('Total profitable trade pair :'+ str((finalresult-len(trade_list)*10000)/len(trade_list)/10000) + '%')
    df_trade_summary = pd.DataFrame(trade_summary, columns=['long', 'unit_long', 'short', 'unit_short', 'return', 'price_long', 'price_short', 'percent_change'])
    df_trade_summary.to_csv('D:/data/algo_package/trade_summary.csv')

    return 0
##########################
main()
